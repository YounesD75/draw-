#include <SDL2/SDL.h>
#include <stdio.h>
#include <math.h>

// Fonction pour dessiner un trait entre deux points
void drawLine(SDL_Renderer *renderer, int x1, int y1, int x2, int y2) {
    SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
}

// Fonction pour dessiner un curseur en forme de cercle bleu
void drawCursor(SDL_Renderer *renderer, int x, int y) {
    int radius = 5;  // Taille du curseur (cercle)
    // Couleur du curseur (bleu ici)
    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);  // Bleu
    // Dessiner un cercle
    for (int w = -radius; w < radius; w++) {
        for (int h = -radius; h < radius; h++) {
            if (w * w + h * h <= radius * radius) {  // Vérifie si le point est dans le cercle
                SDL_RenderDrawPoint(renderer, x + w, y + h);
            }
        }
    }
}

// Fonction pour déplacer le curseur
void moveCursor(int *x, int *y, int dx, int dy) {
    *x += dx;
    *y += dy;
}

// Fonction pour faire pivoter un point autour de l'origine (x, y) par un angle donné en degrés
void rotateCursor(int *dx, int *dy, double angle) {
    double angleRad = angle * M_PI / 180.0;  // Convertir l'angle en radians
    double newDx = *dx * cos(angleRad) - *dy * sin(angleRad);
    double newDy = *dx * sin(angleRad) + *dy * cos(angleRad);
    *dx = (int)newDx;
    *dy = (int)newDy;
}

int main() {
    // Initialisation de SDL
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        fprintf(stderr, "Erreur SDL_Init: %s\n", SDL_GetError());
        return 1;
    }

    // Création d'une fenêtre
    SDL_Window *window = SDL_CreateWindow("Curseur et Dessin de Carré",
                                          SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                                          800, 800, SDL_WINDOW_SHOWN);
    if (!window) {
        fprintf(stderr, "Erreur SDL_CreateWindow: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // Création d'un rendu pour dessiner sur la fenêtre
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer) {
        fprintf(stderr, "Erreur SDL_CreateRenderer: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // Définir la couleur de fond (blanc ici)
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderClear(renderer);  // Remplir l'écran de blanc

    // Définir la couleur de dessin des lignes (noir ici)
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);  // Noir

    // Position initiale du curseur
    int x = 400, y = 400;
    int size = 100;  // Taille du carré
    int dx = size, dy = 90;  // Direction initiale (déplacement horizontal)
    int startX = x, startY = y;

    // Dessiner chaque côté du carré
    for (int i = 0; i < 4; i++) {
        // Avancer le curseur de "size" pixels dans la direction actuelle
        moveCursor(&x, &y, dx, dy);

        // Dessiner un trait entre la position actuelle et précédente
        drawLine(renderer, startX, startY, x, y);

        // Sauvegarder la position pour le prochain déplacement
        startX = x;
        startY = y;

        // Afficher le curseur à chaque étape (ici en forme de cercle bleu)
        drawCursor(renderer, x, y);

        // Pivoter le curseur de 90 degrés pour dessiner le prochain côté du carré
        rotateCursor(&dx, &dy, 90);

        // Afficher le dessin après chaque ligne pour un effet progressif
        SDL_RenderPresent(renderer);
        SDL_Delay(500);  // Attendre un peu pour rendre le dessin progressif
    }
    	rotateCursor(&dx,&dy,-90);
	moveCursor(&x, &y, dx, dy);
	drawLine(renderer, startX, startY, x, y);
	drawCursor(renderer, x, y);
	SDL_RenderPresent(renderer);
        SDL_Delay(500);  
    // Boucle d'événements pour garder la fenêtre ouverte
    SDL_Event e;
    int quit = 0;
    while (!quit) {
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) {
                quit = 1;
            }
        }
    }

    // Nettoyer et quitter
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
